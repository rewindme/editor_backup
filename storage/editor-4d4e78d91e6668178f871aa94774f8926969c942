{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":23,"width":2560,"height":1372,"maximized":true},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/naver/nhn_work/git/Coding-Convention","/Users/naver/nhn_work/git/mail"],"buffers":[{"text":"= 네이버 코딩 컨벤션 (C/C++)\n:revnumber: v0.0\n\n== 들여쓰기 (Indentation)\n클래스, 메서드, 제어문의 블럭이 생길 때마다 왼쪽 첫 번째 칼럼부터 오른쪽으로 일정한 간격만큼 띄어 쓰는 것을 들여쓰기라고 한다.\n많은 C/C++ 프로젝트들은 서로 다른 들여쓰기 방법들을 사용하고 있는데, 대체로 아래 3가지 정도를 주로 사용하고 있다.\n\n. 하드 탭(Tab)\n. 공백 2칸(2 spaces)\n. 공백 4칸(4 spaces)\n\n가장 중요한 것은 프로젝트/파일 단위에서의 통일성이므로 기존의 프로젝트/파일이 정의하는 스타일을 따르되, 신규 프로젝트나 코딩 컨벤션이 모호한 경우 아래 가이드라인을 지켜야 한다.\n\n=== Tab 사용 금지 [indentation-no-tab]\n모든 들여쓰기는 공백(space)을 사용한다. Tab은 문법적인 의미를 갖는 경우에만 사용한다.(예 - Makefiles)\n\n=== 들여쓰기 간격 [indentation-4-spaces]\n들여쓰기 간격은 공백4칸(4 spaces)으로 한다.\n\n[source,cpp]\n.나쁜 예\n----\nint somethingTodo(int i)\n{\n  if (condition) {\n    test();\n    return 0;\n  }\n  return i;\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nint somethingTodo(int i)\n{\n    if (condition) {\n        test();\n        return 0;\n    }\n    return i;\n}\n----\n\n=== 논리 연산식 들여쓰기 [indentation-wrap-bool-op]\n조건문이 다수의 논리 연산자로 구성되고, 한 줄에 모두 표기할 수 없는 경우에는 논리 연산식을 여러줄에 나누어 표기할 수 있다.\n논리 연산자를 한줄에 하나씩 배치하거나, 논리적 연산 순서에 따라 묶어서 배치한다.\n논리 연산자를 기준으로 줄을 바꾸었을 경우, 두 번째 줄부터 들여쓰기는 첫 번째 논리 연산식이 시작한 칼럼에서 공백4칸만큼 오른쪽으로 들여쓴다.\n\nNOTE: 두 단계 이상 논리 연산식을 중첩하는 것도 가능하지만, 논리 연산식을 중첩할 수록 코드를 읽기 어려워질 수 있으므로 연산식은 가능한 단순하게 유지하는 것이 좋다.\n만약 필요 이상으로 복잡한 조건이 존재할 경우 인라인 함수등으로 만드는 것이 가능한지 고려할 필요가 있다.\n\n[source,cpp]\n.나쁜 예\n----\nif (longConditionToSpanMultipleLine1 &&\n    conditions2) {\n    ....\n}\n\nif (condition1 && condition2\n    && longConditionToSpanMultipleLine3) {\n    ....\n}\n\nif (longConditionToSpanMultipleLine1\n    && (longConditionToSpanMultipleLine2\n    || condition3)) {\n    ....\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nif (longConditionToSpanMultipleLine1\n    && longConditionToSpanMultipleLine2) {\n    ....\n}\n\nif (condition1\n    && condition2\n    && longConditionToSpanMultipleLine3) {\n    ....\n}\n\nif (longConditionToSpanMultipleLine1\n    && (longConditionToSpanMultipleLine2\n        || condition3)) {\n    ....\n}\n----\n\n=== Enum 들여쓰기 [indentation-enum]\nEnumeration 타입이 많거나 긴 경우 여러줄에 나누어 정의할 수 있다.\n여러줄에 나누어 정의할 경우, 각 항목을 새로운 줄에 작성하고 들여쓰기를 한다.\n\n[source,cpp]\n.나쁜 예\n----\nenum ScrollbarTypeAndOrientation {\n    NormalVertical, NormalHorizontal,\n    TinyVertical, TinyHorizontal,\n};\n\nenum SimpleEnums { S1, S2\n};\n----\n\n[source,cpp]\n.좋은 예\n----\nenum ScrollbarTypeAndOrientation {\n    NormalVertical,\n    NormalHorizontal,\n    TinyVertical,\n    TinyHorizontal,\n};\n\nenum SimpleEnums { S1, S2 };\n----\n\n=== 함수 들여쓰기 [indentation-function]\n메소드나 함수의 선언/정의가 너무 길다고 생각되면 여러줄에 나누어 선언/정의할 수 있다.\n여러줄에 나누어 정의할 경우, 첫 번째 항목을 포함하여 각 항목을 새로운 줄에 작성하고 들여쓰기를 한다.\n들여쓰기는 다른 들여쓰기와 마찬가지로 공백 4칸으로 한다.\n\nNOTE: 프로젝트에 따라 한 줄에 놓을 수 있는 글자 수에 제한이 있을 수 있는데(예 - 80자 이하, 120자 이하), 이러한 제한이 있는 경우가 아니라면 줄 바꿈이 필요한지 여부는 개발자가 적절히 선택할 수 있다.\n다만, 선언에서 여러줄에 나누어 선언했다면 정의에서도 똑같이 하는 것을 권장한다.\n\n[source,cpp]\n.나쁜 예\n----\nvoid simpleFunction(\n    parameter1);\n\nvoid someFunctionThatParametersAreLongEnough(\n        longParameters1,\n        parameter2,\n        parameter3);\n\nvoid someFunctionThatParametersAreLongEnough2(longParameters1\n    , parameter2\n    , parameter4);\n\nvoid someFunctionThatParametersAreLongEnough3(\n    longParameters1,\n    parameter4\n);\n----\n\n[source,cpp]\n.권장하지 않는 예\n----\nvoid someFunction2ThatParametersAreLongEnough(longParameters1,\n    parameter2,\n    parameter3);\n\nvoid someFunction2ThatParametersAreLongEnough(\n    longParameter1,\n    parameter2, parameter3,\n    longParameter4);\n\nvoid someFunction2ThatParametersAreLongEnough2(longParameters1,\n                                               parameter2,\n                                               parameter3);\n----\n\n[source,cpp]\n.좋은 예\n----\nvoid simpleFunction(parameter1);\n\nvoid someFunctionThatParametersAreLongEnough(\n    longParameters1,\n    parameter2,\n    parameter3,\n    parameter4);\n\nvoid someFunctionThatParametersAreLongButNotSpannedToMultiLine(longParameters1, parameter2, parameter4);\n----\n\n=== 초기화 리스트 들여쓰기 [indentation-initializer]\n생성자의 초기화 리스트는 생성자 아래 줄에 들여쓰기 후 작성한다. 각 항목들은 모두 자신의 줄을 갖도록 작성한다.\n\n[source,cpp]\n.나쁜 예\n----\nSomeClass::SomeClass(int parameter1, int parameter2)\n    : m_member1(parameter1), m_member2(parameter2)\n{\n}\n\nSomeClass2::SomeClass2(int parameter1) : m_member1(parameter1)\n{\n}\n\n\nSomeClass3::SomeClass3(int parameter1) :\n    m_member1(parameter1),\n    m_member2(0)\n{\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nSomeClass::SomeClass(int parameter1, int parameter2)\n    : m_member1(parameter1)\n    , m_member2(parameter2)\n{\n}\n----\n\n== 공백 (Spacing)\n단어와 단어 사이, 연산자의 앞과 뒤, 문장부호(콤마, 콜론 등) 다음에는 한 칸을 띄어 쓴다.\n\n[source,cpp]\n.좋은 예\n----\nvoid functionName(param1, param2, param3);\n\nfor (int i = 0; i < 10; i++) {\n    ....\n}\n\na = b + (c / (*d));\n----\n\n=== 단항 연산자의 공백 사용 금지 [spacing-unary-op]\n단항 연산자의 경우 공백을 사용하지 않는다.\n\n[source,cpp]\n.나쁜 예\n----\ni ++;\n++ i;\n----\n\n[source,cpp]\n.좋은 예\n----\ni++;\n++i;\n----\n\n=== 이항 연산자와 삼항 연산자의 공백 사용 [spacing-binary-ternary-op]\n이항 연산자와 삼항 연산자는 공백을 사용한다.\n\n[source,cpp]\n.나쁜 예\n----\ny=m*x+b;\nf(a,b);\nc = a|b;\nreturn condition ? 1:0;\n----\n\n[source,cpp]\n.좋은 예\n----\ny = m * x + b;\nf(a, b);\nc = a | b;\nreturn condition ? 1 : 0;\n----\n\n=== Range 기반 루프의 콜론 앞 뒤에 공백 사용 [spacing-for-colon-in-range-loop]\nc++11부터 도입된 range 기반(ranged-based) for 루프의 콜론 앞과 뒤에는 공백을 사용한다.\n\n[source,cpp]\n.나쁜 예\n----\nfor (auto& i: members) {\n    ....\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nfor (auto& i : members) {\n    ....\n}\n----\n\n=== 콤마와 세미콜론 앞 공백 사용 금지 [spacing-comma-semicolon]\n콤마와 세미콜론 앞에는 공백을 사용하지 않는다.\n\n[source,cpp]\n.나쁜 예\n----\nmyFunc(1 , 2);\nmyFunc(1, 2) ;\nwhile (insertAfterRead()) ;\n----\n\n[source,cpp]\n.좋은 예\n----\nmyFunc(1, 2);\nwhile (insertAfterRead());\n----\n\n=== 조건문에서의 공백 [spacing-conditionals]\n조건문과 괄호 사이에는 공백을 사용한다.\n괄호와 논리 연산자 사이에는 공백을 사용하지 않는다.\n괄호와 중괄호 사이에는 공백을 사용한다.\n\n[source,cpp]\n.나쁜 예\n----\nif(condition) {\n}\n\nif (condition){\n}\n\nif ( condition) {\n}\n\nif (condition ) {\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nif (condition) {\n}\n\nif (condition1 && condition2) {\n}\n----\n\n=== 함수명과 괄호 사이 공백 사용 금지\n함수 이름과 괄호사이에는 공백을 사용하지 않는다.\n\n[source,cpp]\n.나쁜 예\n----\nvoid myFunc (int i);\n----\n\n[source,cpp]\n.좋은 예\n----\nvoid myFunc(int i);\n----\n\n== 줄바꿈 (Line breaking)\n줄바꿈은 들여쓰기와 함께 소스코드의 흐름을 이해하는 데 도움을 준다.\n한 줄에 하나의 문장(statement)을 작성하는 것이 일반적이며, 조건문의 블럭에 대한 줄바꿈은 프로젝트마다 다른 방법을 사용하기도 한다.\n대체로 아래 두가지 방법들이 대표적이다.\n\n[source,cpp]\nif (condition) {\n    ...\n} else {\n    ...\n}\n\n[source,cpp]\nif (condition)\n{\n    ...\n}\nelse\n{\n    ...\n}\n\n=== 문장단위 줄바꿈 [linebreak-multiple-statements]\n한 줄에는 반드시 한 문장만 있어야 한다.\n\n[source,cpp]\n.나쁜 예\n----\nx++; y++;\nif (condition) doIt();\nif (condition2) return;\n----\n\n[source,cpp]\n.좋은 예\n----\nx++;\ny++;\nif (condition)\n    doIt();\nif (condition2)\n    return;\n----\n\n=== 조건문에서의 줄바꿈 [linebreak-else-braces]\nelse문과 else if문은 이전 if 문의 중괄호 뒤에 공백을 주고 작성한다.\n\n[source,cpp]\n.나쁜 예\n----\nif (condition)\n{\n    ....\n}\nelse if (condition2)\n{\n    ....\n}\nelse\n{\n    ....\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nif (condition) {\n    ....\n} else if (condition2) {\n    ....\n} else {\n    ....\n}\n----\n\n\n== 중괄호 (Braces)\n중괄호는 클래스, 메서드, 제어문의 블럭을 구분한다.\n\n=== 함수 정의시 중괄호 [brances-function]\n함수 정의시 중괄호는 자신의 줄에 작성한다.\n\n[source,cpp]\n.나쁜 예\n----\nint main() {\n    ....\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nint main()\n{\n    ...\n}\n----\n\n=== 그 밖의 중괄호 [braces-others]\n코드 블럭을 이끄는 문장과 같은 줄에 여는 중괄호를 배치한다. 닫는 중괄호는 자신의 줄에 작성한다.\n\n[source,cpp]\n.권장하지 않는 예\n----\nclass MyClass\n{\n    ....\n};\n----\n\n[source,cpp]\n.좋은 예\n----\nclass MyClass {\n    ....\n};\n\nnamespace MyNameSpace {\n    ....\n}\n\nfor (int i = 0; i < 10; ++i) {\n    ....\n}\n----\n\n=== 한줄 조건문 [braces-one-line-condition]\n한 줄 조건문은 특별히 중괄호 없이 사용한다. 단, 주석이 필요하거나 문장이 두 줄 이상을 차지할 경우에는 중괄호를 사용해야 한다.\n\n[source,cpp]\n.나쁜 예\n----\nif (condition) {\n    doIt();\n}\n\nif (condition)\n    // Some comments\n    doIt();\n\nif (condition)\n    someLongFunction(longParam1, longParam2, ...\n        lastLongParam);\n----\n\n[source,cpp]\n.좋은 예\n----\nif (condition)\n    doIt();\n\nif (condition) {\n    // Some comments\n    doIt();\n}\n\nif (condition) {\n    someLongFunction(longParam1, longParam2, ...\n        lastLongParam);\n}\n----\n\n\n== Null, false과 zero(Null, false and zero)\n\n=== nullptr 사용 [zero-nullptr]\nC++11이 사용 가능하다면 nullptr을 사용한다. 그렇지 않다면 0을 사용한다. C는 NULL을 사용한다.\n\n=== true/false 사용 [zero-true]\nbool 값은 true와 false를 사용한다.\n\n=== 동등 비교 지양 [zero-comparison]\n조건문에서 null 조건 비교, boolean 조건 비교는 동등 비교 연산자를 사용하지 않는다.\n\n[source,cpp]\n.나쁜 예\n----\nif (value == nullptr) {\n    ....\n}\n\nif (condition == true)\n    doIt();\n\nif (count == 0) {\n    ....\n}\n----\n\n[source,cpp]\n.좋은 예\n----\nif (!value) {\n    ....\n}\n\nif (condition)\n    doIt();\n\nif (!count) {\n    ....\n}\n----\n\n\n== 이름 (Names)\n소스 코드에는 변수명, 클래스명, 파일명등 다양한 이름들이 존재한다. 모든 이름들은 간결하면서도 정확한 의미를 담고 있어야 하고 나중에 읽기 쉽고 이해하기 쉬운 형태이어야 한다.\n많은 프로젝트들이 서로 다른 작명 스타일을 갖고 있을 수 있기 때문에 가장 중요한 것은 해당 프로젝트가 갖는 작명 규칙에 맞추는 것이다.\n아래 가이드라인은 가능한 지켜야 하는 부분들을 제시한다. 통일성있는 작명을 위해 프로젝트의 컨벤션을 프로젝트 내에 유지하는 것이 바람직하다.\n\n=== 간결성, 명료성 준수 [names-unambiguity]\n역할과 목적을 잘 나타낼 수 있도록 간결하면서도 명확해야 한다. 같은 변수명이라고 하더라도 문맥에 따라 간결하고 명료한 이름일 수도 있고 아닐 수도 있다.\n예를 들어, `setColor(Color color)`는 하나의 색 속성을 갖는 객체의 메소드로는 명료할 수도 있지만, 여러 종류의 색이 필요할 수 있는 객체의 메소드로는 명료하지 않을 수 있다.\n\n=== 언더스코어('_') 사용 지양 [names-underscore]\n파일, 프로젝트, 매크로 이름은 언더스코어('_')를 사용하여 시작하지 않는다. 언더스코어('_')로 시작하는 이름은 컴파일러가 내부에서 사용하고 있는 이름들과 충돌이 있을 수 있다.\n\n=== 한 글자 이름 지양 [names-one-letter]\n한 글자로 사용하는 이름은 의미를 기억하기가 어려워 오류를 범할 가능성이 높다. 단, 관용적으로 많이 사용하는 반복문의 변수 이름(예 - i, j)으로 한글자를 사용할 수 있다.\n\n=== 약어 사용 지양 [names-full-word]\n약어를 사용하지 않고, 전체 이름을 사용한다. 단, 일반적으로 널리 알려져 다른 도메인의 개발자도 쉽게 이해하고 더 이해하기 쉬운 대표적인 약어는 약어를 사용한다.\n\n[source,cpp]\n.나쁜 예\n----\nint m_NPDelegate;\nint m_currentUniformResourceLocator;\n----\n\n[source,cpp]\n.좋은 예\n----\nint m_networkProcessDelegate;\nint m_currentURL;\n----\n\n=== 동사 먼저 [names-function-verb]\n함수 이름은 동사로 시작한다.\n\n[source,cpp]\n.나쁜 예\n----\nbool availableNetwork();\n----\n\n[source,cpp]\n.좋은 예\n----\nbool isAvailableNetwork();\n----\n\n=== 변수의 prefix [names-variables-prefix]\n멤버 변수 가운데 static 멤버는 반드시 s_ 으로 시작해야 한다. 나머지 멤버 변수들은 m_ 으로 시작해야 한다. 전역 변수가 필요한 경우에는 g_ 으로 시작해야 한다.\n\n=== 변수 이름 [names-variable]\n변수 이름이 두 단어 이상으로 이루어진 경우 각 단어의 첫번째 글자는 대문자로 하고 나머지는 소문자료 한다.\n\n[source,cpp]\n.나쁜 예\n----\nint m_myvariabletodo;\n----\n\n[source,cpp]\n.좋은 예\n----\nint m_myVariableToDo;\n----\n\n=== 상수 이름 [names-constant]\n상수 이름은 대문자와 언더스코어('_')만 사용하여 작성한다.\n\n[source,cpp]\n.좋은 예\n----\nconst int SOME_CONSTANT = 0;\n----\n\n=== 대표 클래스 이름 사용 준수 [names-file-class-name]\n소스 코드의 파일 이름은 파일 내의 대표 클래스 이름과 동일하게 작성한다. 대표 클래스의 Prefix 'C' 는 생략 가능하다.\n\n== 헤더 파일 (Include statements)\n일반적으로 C++은 구현부와 선언부를 분리하여 별도의 파일로 관리하고 구현파일(.cpp)에서 #include를 통해 헤더파일(.h)를 포함하게 된다.\n#include로 포함되 헤더파일들은 전처리기에 의해 구현파일에 포함되는데, 가능한 적은 헤더파일을 포함하고 중첩된 포함관계를 갖지 않는 것이 바람직하다.\n\n아래는 헤더 파일과 관련한 좋은 예제이다.\n[source,cpp]\n.좋은 예 (Foo.cpp)\n----\n/* Copyright if needed ...\n * ...\n */\n\n#include \"config.h\"\n#include \"Foo.h\"\n\n#include \"AOtherHeaderFile.h\"\n#include \"BOtherHeaderFile.h\"\n#include \"a-header.h\"\n#include \"b-header.h\"\n#include <ASystemHeaderFile.h>\n#include <BSystemHeaderFile.h>\n#include <a-system-header.h>\n#include <b-system-header.h>\n\n#if SOME_CONDITION\n#include ...\n#endif\n\n...\n----\n\n=== 연관 헤더부터 포함 [include-primary]\n일반적으로 구현파일(.cpp)은 연관이 있는 헤더 파일을 가져야 한다. 예를 들어 foo.cpp가 있다면 foo.h가 있어야 하고 이를 include하여야 한다.\n구현파일은 가장 먼저 연관이 있느 헤더 파일부터 포함해야 한다.\n단, 프로젝트에 따라 config.h와 같이 약속된 헤더를 먼저 포함할 수 있다.\n\n=== 헤더 파일들의 포함 [include-others]\n프로젝트에서 사용하는 다른 헤더 파일들은 연관 헤더 파일 다음에 한 줄을 비우고 알파벳 순서로 적는다.\n\n=== 시스템 헤더 파일들의 포함 [include-system]\n시스템 헤더 파일들은 프로젝트에서 사용하는 다른 헤더 파일들 다음에 알파벳 순서로 적는다.\n\n=== 매크로 안의 헤더 파일 [include-if-macro]\n필요에 따라, #if / #ifdef 와 같은 매크로를 이용해 특정 조건에서만 포함되는 헤더 파일들은 다른 헤더 파일들 이후에 한 줄을 비우고 적는다.\n\n=== 헤더 파일에서의 include [include-in-header-file]\n헤더 파일에서는 가능한 다른 헤더 파일의 포함을 최소화해야 한다. 전방 선언을 최대한 활용하되 여의치 않는 경우에 한해 헤더 파일을 직접 포함할 수 있다.\n\n== 주석 (Comments)\n주석은 복잡한 프로그램의 이해를 돕기 위해서 또는 기억해 두어야 할 사항(예 - FIXME)을 표기하기 위해 사용한다.\n그러나 소스 코드만으로 충분히 이해가 가는 내용이나 시간이 지남에 따라 의미가 사라지는 정보들을 주석으로 작성하면 오히려 주석이 코드 이해를 방해하기도 한다.\n따라서, 가능한 주석이 필요없는 소스코드를 작성해야 하며, 주석은 꼭 필요한 경우에 한해 모호함이 없고 명료하게 작성해야 한다.\n\n=== 주석 작성 위치 [comment-location]\n주석은 어느 소스 코드의 주석인지 명확하게 알 수 있어야 하므로 소스 코드와 최대한 가까운 곳에 작성한다.\n\n=== 영문 사용 [comment-english]\n주석은 영어로 작성한다. 단 문서 생성을 위한 주석으로, 툴이 언어별 주석 표현법을 제공하는 경우에는 다른 언어를 사용하여 작성할 수 있다.\n","markerStore":{"version":2,"nextMarkerId":3,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":20}},"properties":{"type":"selection","editorId":439,"goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"}}},"history":{"version":2,"nextCheckpointId":2,"undoStack":[{"type":"checkpoint","id":1,"snapshot":{"0":{"range":[[0,0],[0,20]],"properties":{"type":"selection","editorId":439,"goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"},"2":{"range":[[343,5],[343,11]],"properties":{"replicate":false},"reversed":false,"tailed":true,"valid":true,"invalidate":"touch"}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/naver/nhn_work/git/Coding-Convention/cpp/src/index.adoc","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"1cca148c5351e7cf51ddd1894089083e5d972839","deserializer":"TextBuffer","version":2},{"text":"= 네이버 코딩 컨벤션 (Java)\n:revnumber: v0.7\n\n== 중괄호 (Brace)\n중괄호는 클래스, 메서드, 제어문의 블럭을 구분한다.\n\n=== 줄의 끝에서 중괄호 시작\n중괄호는  클래스 선언, 메서드 선언, 조건/반복문 줄의 마지막에서 시작한다.\n\n[source,java]\n.나쁜 예\n----\npublic class SearchConditionParser\n{\n    public boolean isValidExpression(String exp)\n    {\n\n        if (exp == null)\n        {\n            return false;\n        }\n\n        for (char ch : exp.toCharArray())\n        {\n             ....\n        }\n\n        return true;\n    }\n}\n----\n\n[source,java]\n.좋은 예\n----\npublic class SearchConditionParser {\n    public boolean isValidExpression(String exp) {\n\n        if (exp == null) {\n            return false;\n        }\n\n        for (char ch : exp.toCharArray()) {\n            ....\n        }\n\n        return true;\n    }\n}\n----\n\n=== 제어문에 중괄호 사용\n조건, 반복문이 한줄로 끝더라도 중괄호를 활용한다. 이 문서에 언급된 중괄호의 전후의 공백, 제어문 앞 두의 새줄 규칙도 함께 고려한다.\n\n[source,java]\n.나쁜 예\n----\nif (exp == null) return false;\n\nfor (char ch : exp.toCharArray()) if (ch == 0) return false;\n----\n\n[source,java]\n.좋은 예\n----\nif (exp == null) {\n    return false;\n}\n\nfor (char ch : exp.toCharArray()) {\n\n    if (ch == 0) {\n        return false;\n    }\n\n}\n----\n\n== 줄바꿈 (Line wrapping)\n줄 바꿈은 작성한 명령어가 줄 너비를 초과했을 경우 코드 가독성을 위해서 강제로 줄을 바꾸는 것을 말한다. 명령문을 길게 작성하면 소스 코드 분석이 어려워지므로 줄바꿈 규칙을 의식한다.\n\n=== 최대 줄 너비는 120\n최대 줄 사용 너비는 120자까지 가능하다.\n\n=== 최대 줄 너비 초과시 줄바꿈 권장 위치 준수\n최대 길이를 초과할 때 줄을 바꾸는 위치는 다음을 권장한다.\n\n* 콤마(`,`) 다음\n* 연산자 전에\n* 시작 소괄호(`(`)의 선언 후\n* extends 키워드 다음\n* implments 키워드 다음\n* throws 키워드 다음\n\n.좋은 예\n----\n// 짧은 선언으로 표현했으나 줄이 길어진 상황으로 가정함\n\npublic boolen isAbnormalAccess(\n    User user, AccessLog log) {\n\n    String message = user.getId() + \"|\" | log.getPrefix()\n        + \"|\" + SUFFIX;\n}\n----\n\n\n=== else if, else문 새 줄 사용 금지\nelse if, else문 전에 새 줄을 사용하지 않는다.\n\n[source,java]\n.나쁜 예\n----\nif (name.startWith(WARNING_PREFIX)) {\n    return LogPattern.WARN;\n}\nelse if (name.startWith(DANGER_PREFIX)) {\n    return LogPattern.NORMAL;\n}\nelse {\n    return LogPattern.NORMAL;\n}\n----\n\n[source,java]\n.좋은 예\n----\nif (name.startWith(WARNING_PREFIX)) {\n    return LogPattern.WARN;\n} else if (name.startWith(DANGER_PREFIX)) {\n    return LogPattern.NORMAL;\n} else {\n    return LogPattern.NORMAL;\n}\n----\n\n=== catch, finally문 새 줄 사용 금지\ncatch, finally문 전에 새 줄을 사용하지 않는다.\n[source,java]\n.나쁜 예\n----\ntry {\n    writeLog();\n}\ncatch (IOException ioe) {\n    reportFailure(ioe);\n}\nfinally {\n    writeFooter();\n}\n----\n\n[source,java]\n.좋은 예\n----\ntry {\n    writeLog();\n} catch (IOException ioe) {\n    reportFailure(ioe);\n} finally {\n    writeFooter();\n}\n----\n\n== 빈 줄(Blank lines)\n빈 줄은 명령문 그룹의 영역을 표시하기 위하여 사용한다. 특정 로직을 처리하는 수 많은 명령문이 구분 없이 혼재하여 있거나 제어문과 명령문 사이의 영역을 구분하지 않으면 소스 코드 분석이 어려워진다.\n\n=== import 그룹간의 빈 줄 삽입\njava, javax, org, net, com, com.naver 순서로 import 구문을 그룹화한다. 그룹간에는 빈 줄을 사용하여 구분한다.\n\n[source,java]\n.좋은 예\n----\nimport java.util.Date;\nimport java.util.List;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.util.Assert;\n\nimport com.ibatis.sqlmap.client.SqlMapClient;\n\nimport com.naver.lucy.util.AnnotationUtils;\n----\n\n=== package 선언 후 빈 줄 삽입\n[source,java]\n.좋은 예\n----\npackage com.naver.lucy.util;\n\nimport java.util.Date;\n----\n\n=== 메소드 사이의 빈 줄 삽입\n메서드의 선언이 끝난 후 다음 메서드 선언이 시작되기 전에 빈줄을 삽입한다.\n\n[source,java]\n.좋은 예\n----\npublic void setId(int id) {\n    this.id = id;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n----\n\n=== 제어문 앞 뒤의 빈 줄 삽입\nif, for 문 등의 제어문 블럭 앞 뒤에는 빈줄을 삽입한다.\n\n[source,java]\n.좋은 예\n----\nprintStartMessage();\n\nfor (char ch : exp.toCharArray()) {\n\n    if (ch == 0) {\n        printWarning();\n    }\n\n}\n\nprintEndMessage();\n----\n\n== 공백 (White spaces)\n\n=== 대괄호 뒤의 공백 삽입\n대괄호를 닫은 후 ';'으로 문장이 끝나지 않고 다른 선언이 올 경우 공백을 삽입한다.\n\n[source,java]\n.나쁜 예\n----\nint[]masks = new int[]{0, 1, 1};\n----\n\n[source,java]\n.좋은 예\n----\nint[] masks = new int[] {0, 1, 1};\n----\n\n=== 중괄호의 시작 앞에는 공백 삽입\n중괄호를 열기 전에는 공백을 삽입한다.\n\n[source,java]\n.좋은 예\n----\nclass Launcher {\n    public static void main(String[] ags) {\n\n    }\n}\n\n----\n\n=== 제어문에서 소괄호 앞에 공백 삽입\n소괄호(`(`,`)`)를 제어문 키워드(`if`, `for`, `while` 등)와 함께 사용하는 경우에 시작 소괄호(`(`) 앞에 공백을 삽입한다.\n\n[source,java]\n.나쁜 예\n----\nif(maxLine > LIMITED) {\n\treturn false;\n}\n\nfor(int i = 0; i < maxLine; i++) {\n\t...\n}\n----\n\n[source,java]\n.좋은 예\n----\nif (maxLine > LIMITED) {\n\treturn false;\n}\n\nfor (int i = 0; i < maxLine; i++) {\n\t...\n}\n----\n\n=== 메서드 선언 시의 소괄호 앞에 공백 미삽입\n메서드 선언, 메서드 호출, 타입 캐스팅에는 공백을 삽입하지 않는다.\n\n[source,java]\n.나쁜 예\n----\npublic String removeEndingDot (String original) {\n    assertNotNull (original);\n    ...\n}\n----\n\n[source,java]\n.좋은 예\n----\npublic String removeEndingDot(String original) {\n    assertNotNull(original);\n    ...\n}\n----\n\n=== 타입캐스팅 시에는 소괄호 앞 뒤로 공백 미삽입\n타입캐스팅을 위해 선언한 소괄호에는 앞뒤에 공백을 삽입하지 않는다.\n\n[source,java]\n.나쁜 예\n----\nString message = ( (String) rawLine).trim();\n----\n\n[source,java]\n.좋은 예\n----\nString message = (String)rawLine;\n----\n\n=== 산괄호를 열고 난 후/닫기 전에는 공백 미삽입\n제네릭 선언에 쓰이는 산괄호 ( `<,>` ) 열고 난 후에 닫기 전에는 공백을 삽입하지 않는다.\n\n[source,java]\n.나쁜 예\n----\npublic static < A extends Annotation > A findAnnotation(AnnotatedElement elem, Class< A > type) {\n----\n\n[source,java]\n.좋은 예\n----\npublic static <A extends Annotation> A findAnnotation(AnnotatedElement elem, Class<A> type) {\n----\n\n=== 콤마 뒤에는 공백 삽입\n콤마(,)는 반드시 뒤에 공백을 삽입한다.\n\n[source,java]\n.나쁜 예\n----\npublic void draw(int x,int y)\n    int[] color = new int[] {0,1,1};\n    draw(x,y,color);\n}\n----\n\n[source,java]\n.좋은 예\n----\npublic void draw(int x, int y)\n    int[] color = new int[] {0, 1, 1};\n    draw(x, y, color);\n}\n----\n\n=== 콜론의 앞 뒤에는 공백 삽입\n반복문과 라벨, 삼항연산자에 콜론의 앞 뒤에는 공백을 삽입한다.\n\n[source,java]\n.좋은 예\n----\nfor (Customer customer : visitedCustomers) {\n    AccessPattern pattern = isAbnomal(accessLog) ? AccessPattern.ABUSE : AccessPattern.NORMAL;\n    int grade = evaluate(customer, pattern);\n\n    switch (grade) {\n        case GOLD :\n            sendSms(customer);\n        case SILVER :\n            sendEmail(customer);\n        default :\n            inreasePoint(customer)\n    }\n}\n----\n\n=== 문장 종료자 세미콜론의 뒤에는 공백 미삽입\n문장르 종료하는 세미콜론(`;`)의 뒤에는 공백을 삽입하지 않는다.\n\n=== 구분자 세미콜론의 뒤에 공백 삽입\n반복문(while, for)의 구분자로 쓰이는 세미콜론(`;`)은 뒤에만 공백을 삽입한다.\n\n[source,java]\n.좋은 예\n----\nfor (int i = 0; i < maxLine; i++) {\n\t...\n}\n----\n\n=== 산술/비교/논리/삼항/대입 연산자에는 공백 삽입\n증감, 감소연산자를 제외한 산술/비교/논리/삼항/대입 연산자의 앞 뒤에는 공백을 삽입한다.\n\n[source,java]\n.좋은 예\n----\nif (pattern == Access.ABNORMAL) {\n    return 0;\n}\n\nfinalScore += weight * rawScore - absentCount;\nif (finalScore > MAX_LIMIT) {\n    return MAX_LIMIT;\n}\n----\n\n=== 증감, 감소 연산자에는 공백을 미삽입\n`++`,`--`와 같은 증감, 감소 연산자의 앞뒤에는 공백을 삽입하지 않는다.\n\n[source,java]\n.나쁜 예\n----\nint point = score[ ++ index] * -- rank;\n----\n\n[source,java]\n.좋은 예\n----\nint point = score[++index] * --rank;\n----\n\n== 이름\n\n=== 공통 규칙\n\n==== 영문 사용\n소스의 변수명, 클래스명 등에는 영문 이외의 언어를 사용하지 않는다. 단 테스트코드의 메서드명 등에서는 조직내부의 합의에 따라서 한글을 사용할 수 있다.\n\n==== 한글 발음 사용 금지\n한글 발음을 그대로 사용하지 않는다.\n\n- 나쁜 예 : `moohyungJasan` (무형자산)\n- 좋은 예 : `intangibleAssets` (무형자산)\n\n==== 특수 문자 사용 금지\n클래스, 메소드 등의 이름에는 특수 문자를 사용하지 않는다. 단, 상수의 이름에는 단어 구분을 위하여 언더스코어(‘_’)를 사용한다.\n\n==== 모두 대문자 표기할 약어 명시\n클래스명, 변수명에 쓰일 단어 중 모든 글자를 대문자로 표기할 약어의 목록을 프로젝트별로 명시적으로 정의한다.\n\n약어의 대소문자 표기는 JDK의 클래스나 라이브러리들 사이에서도 일관된 규칙이 없다.\n`javax.xml.bind.annotation.XmlElement`처럼 약어를 소문자로 표기하기도 하고, `java.net.HttpURLConnection`처럼 한 클래스 안에서 단어별로 다르게 쓰기도 했다.\n그러나 단일 프로젝트에서는 규칙이 명확하지 않으면 같은 단어의 조합을 다른 이름으로 표기할 수 있어서 혼동을 유발한다.\n\n약어가 클래스명에서 대문자로 들어가면 단어 간의 구분을 인지하기에 불리하다. 약어가 연속된 경우 더욱 가독성을 해친다. 예를 들면 XMLRPCHTTPAPIURL과 같은 경우이다.\n그래서 기본 정책으로는 약어의 중간단어를 소문자로 표기하고 프로젝트별로 모두 대문자로 표기할 약어의 목록을 명시하는 방식이 가독성을 높이고 규칙을 단순화하는데 유리하다.\n즉 프로젝트 내에서 정의한 단어 목록이 없다면 'XmlRpcHttpApiUrl'과 같이 쓴다.\n\n.좋은 예\nHTTP + API + URL 의 클래스 이름의 경우\n\n* 대문자로 표기할 약어의 목록을 정의하지 않는 경우 : HttpApiUrl\n* API만 대문자로 표기할 약어의 목록에 있을 경우 : HttpAPIUrl\n* HTTP, API, URL이 대문자로 표기할 약어의 목록에 있을 경우 : HTTPAPIURL\n\n=== 패키지명\n\n==== 소문자 사용\n패키지 이름은 소문자를 사용하여 작성한다. 단어별 구문을 위해 언더스코어(`_`)나 대문자를 섞지 않는다.\n\n[source,java]\n.나쁜 예\n----\npackage com.navercorp.apiGateway\n\npackage com.navercorp.api_gateway\n----\n\n[source,java]\n.좋은 예\n----\npackage com.navercorp.apigateway\n----\n\n==== 상위 패키지명 준수\n신규 프로젝트의 패키지 이름은 외부 사용자가 쓰는 서비스는 `com.naver.` 사내 서비스는 `com.navercorp.` 형식으로 시작한다.\n\n=== 클래스명\n\n==== 파스칼 표기법 준수\n여러 단어가 조합된 클래스 이름은 각 단어의 첫 글자를 대문자로 작성한다.\n\n[source,java]\n.나쁜 예\n----\npublic class reservation\n\npublic class Accesstoken\n----\n\n[source,java]\n.좋은 예\n----\npublic class Reservation\n\npublic class AccessToken\n----\n\n==== 명사 사용\n클래스 이름은 명사를 사용하여 작성한다.\n\n[source,java]\n.나쁜 예\n----\npublic class Watch\n\npublic class Insert\n----\n\n[source,java]\n.좋은 예\n----\npublic class Watcher\n\npublic class InsertAction\n----\n\n=== 메서드명\n\n==== 카멜 표기법 준수\n복합어 이름은 첫 번째 단어를 소문자로 작성하고, 두 번째 이상의 단어 첫 글자를 대문자로 작성하여 단어를 구분한다.\n\n==== 동사 또는 전치사로 시작\n메서드명은 기본적으로는 동사로 시작한다 단 다른 타입으로 전환하는 메서드나 빌더 패턴을 구현한 클래스의 메서드에는 전치사를 쓸 수 있다.\n\n.좋은 예\n* 동사사용 : `renderHtml()`\n* 전환메서드의 전치사 : `toString()`\n* Builder 패턴 적용한 클래스의 메서드의 전치사 : `withUserId(String id)`\n\n\n=== 변수명\n====  카멜 표기법 준수\n여러 단어를 조합한 변수는 첫 번째 단어를 소문자로 작성하고, 두 번째 이상의 단어 첫 글자를 대문자로 작성하여 단어를 구분한다.\n\n[source,java]\n.나쁜 예\n----\nboolean Authorized;\nint AccessToken;\n----\n\n[source,java]\n.좋은 예\n----\nboolean authorized;\nint accessToken;\n----\n\n====  관례적인 용법 외에는 1 글자 이름 사용 지양\n반복문의 인덱스나 람다 표현식의 파라미터 등 관례적으로 쓰이는 것을 제외하고는 1 글자 변수명을 지양한다.\n\n[source,java]\n.나쁜 예\n----\nHtmlParser p = new HtmlParser();\n----\n\n[source,java]\n.좋은 예\n----\nHtmlParser parser = new HtmlParser();\n----\n\n=== 상수명\n==== 대문자 사용\n상수 이름은 대문자로 작성하며, 복합어는 언더스코어(‘_’)를 사용하여 단어를 구분한다.\n\n[source,java]\n.좋은 예\n----\npublic final int UNLIMITED = -1;\npublic final String POSTAL_CODE_EXPRESSION = “POST”;\n----\n\n== 주석\n\n=== 주석 기호 뒤에 공백 삽입\n`/*` 혹은 `//` 뒤에 1칸 공백을 삽입한다.\n\n[source,java]\n.좋은 예\n----\n/*\n * 공백을 삽입\n */\n\n// 공백을 삽입\n----\n\n=== 블럭 주석의 종료전 공백 삽입\n 블록 주석을 한 줄로 작성시 끝 ‘*’이전에 공백을 삽입한다.\n\n[source,java]\n.좋은 예\n----\n/* 공백을 삽입 */\n----\n\n=== 클래스 주석에 개발자 이름 포함\n클래스 주석은 개발자의 이름을 포함한다.\n\n[source,java]\n.좋은 예\n----\n\n/**\n * 우편번호로 주소를 찾아주는 클래스\n *\n * @author 정성학\n */\npublic class ZipCodeService {\n    ...\n}\n----\n\n== 개발 도구 설정\n권장하는 코딩 컨벤션을 지키는데 도움이 되는 개발 도구 설정 방법을 정리한다.\n\n=== 한 줄 최대길이\n‘textwidth’ 옵션을 사용한다.\n\n=== Eclipse\n\n=== IntelliJ\n\n=== VI\n==== 탭을 공백4개로 표시\nUnix/Linux는 1탭이 8자리이므로 java소스를 vi에서 확인하는 경우에는 혼란을 유발할 수 있다.\nhome/.vimrc 파일에서 다음을 설정한다.\n\n[source]\n----\nset tabstop = 4, set shiftsize = 4\n----\n","markerStore":{"version":2,"nextMarkerId":33,"markersById":{"0":{"range":{"start":{"row":6,"column":17},"end":{"row":6,"column":17}},"properties":{"type":"selection","editorId":443,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}},"history":{"version":2,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/naver/nhn_work/git/Coding-Convention/java/src/java.adoc","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"0e1df96f374be69c2d70f07431018bd5aa7bc737","deserializer":"TextBuffer","version":2},{"text":"= 네이버 코딩 컨벤션 (JavaScript)\n:revnumber: v0.1\n\n== 들여쓰기 (Indentation)\n\n=== 메소드 체인이 길어지는 경우 적절히 사용한다.\n[source.js]\n.나쁜 예\n----\n$('#items').find('.selected').highlight().end().find('.open').updateCount();\n\nvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true)\n    .attr('width',  (radius + margin) * 2).append('svg:g')\n    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')\n    .call(tron.led);\n----\n\n[source.js]\n.좋은 예\n----\n$('#items')\n  .find('.selected')\n    .highlight()\n    .end()\n  .find('.open')\n    .updateCount();\n\n\n\nvar leds = stage.selectAll('.led')\n    .data(data)\n  .enter().append('svg:svg')\n    .class('led', true)\n    .attr('width',  (radius + margin) * 2)\n  .append('svg:g')\n    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')\n    .call(tron.led);\n----\n\n== 중괄호 (Brace)\n중괄호는 클래스, 메서드, 제어문의 블럭을 구분한다.\n\n=== 줄의 끝에서 중괄호 시작\n중괄호는  클래스 선언, 메서드 선언, 조건/반복문/제어문,줄의 마지막에서 시작한다.\n\n\n[source.js]\n.나쁜 예\n----\nvar Empty = function()\n{\n}\n----\n\n[source.js]\n.좋은 예\n----\nvar Empty = function(){\n\n}\n\nswitch(p){\n\tcase 0 :\n\t\tfield.set(0);\n\t\tbreak;\n\tcase 1 : {\n\t\tbreak;\n\t}\n\tdefault :\n\t\tfield.reset();\n}\n\nif(true){\n\treturn;\n}else if(false){\n\treturn;\n}else{\n}\n\n----\n\n=== 조건/반복문/제어문에 중괄호 사용\n\n조건/반복문/제어문이 한줄로 끝이라도 중괄호를 활용한다.\n\n[source.js]\n.나쁜 예\n----\nif (exp == null) return false;\n\nfor (var i in obj) if ( i === \"stop\" ) return obj[i];\n----\n\n[source.js]\n.좋은 예\n----\nif (exp == null) {\n\treturn false;\n}\n\nfor (var i in obj) {\n\tif ( i === \"stop\" ) {\n\t\treturn obj[i];\n\t}\n}\n----\n\n== 줄바꿈 (Line Wrapping)\n줄 바꿈은 작성한 명령어가 줄 너비를 초과했을 경우 코드 가독성을 위해서 강제로 줄을 바꾸는 것을 말한다. 명령문을 길게 작성하면 소스 코드 분석이 어려워 진다.\n\n=== 최대 줄 너비는 120\n고해상도 모니터(해상도 1280*1024)사용이 보편화 됨에 따라, 최대 줄 사용 너비는 120자까지 가능하다.\n\n=== 한 줄 초과 시 줄 바꿈 준수\n- 변수, 파라미터 등의 경우에는 콤마(,) 다음에 줄 바꿈을 한다.\n- 연산식의 경우에는 연산자 후에 줄 바꿈을 한다.\n- 시작 소괄호( ( )의 경우에는 시작 소괄호( ( ) 전에 줄 바꿈을 한다.\n- 줄 바꿈 후에는 가독성을 위하여 자동 들여쓰기를 한다.\n- 상위 레벨의 깊이에 맞게 들여쓰기를 한다\n\n[source.js]\n.좋은 예\n----\nother.bar(100, 200, 300, 400,\n500, 600, 700, 800, 900);\n\nvar sum = 100 + 200 + 300 + 400 +\n500 + 600 + 700 + 800;\n\nvar arr = [100, 200, 300, 400,\n500, 600, 700, 800, 900];\n----\n\n=== 긴 문자의 경우 줄바꿈시 escape 문자 금지(\\)\nescape문자 대신 +연산사를 사용한다.\n\n[source.js]\n.나쁜 예\n----\nvar text = \"Hello\\\nWorld\";\n----\n\n[source.js]\n.좋은 예\n----\nvar text = \"Hello\" +\n\t\"World\";\n----\n\n== 주석(Comments)\n\n=== 복수행 주석\n/** ... */을 사용하고 함수의 설명과 모든 매개 변수와 반환 값에 대한 형식과 값을 설명합니다.\n\n[source.js]\n.나쁜 예\n----\n// make() returns a new element\n// based on the passed in tag name\n//\n// @param <String> tag\n// @return <Element> element\nfunction make(tag) {\n\t// ...stuff...\n\n\treturn element;\n}\n----\n[source.js]\n.좋은 예\n----\n/**\n * make() returns a new element\n * based on the passed in tag name\n *\n * @param <String> tag\n * @return <Element> element\n */\nfunction make(tag) {\n\t// ...stuff...\n\n\treturn element;\n}\n----\n\n=== 한줄 주석\n복수행을 제외한 상황에서는 \"//\" 한줄 주석을 사용한다. 코드 끝엔 한 줄 주석 지양한다.\n[source.js]\n.나쁜 예\n----\n/* We need an explicit \"bar\", because later in the code foo is checked. */\nvar foo = \"bar\"; // foo\n----\n\n[source.js]\n.좋은 예\n----\n// We need an explicit \"bar\", because later in the code foo is checked.\nvar foo = \"bar\";\n \n// Even long comments that span\n// multiple lines use the single\n// line comment form.\nvar baz = \"bar\"; \n// foo\n----\n\n== 빈 줄(Blank Lines)\n빈 줄은 명령문 그룹의 영역을 표시하기 위하여 사용한다. 특정 로직을 처리하는 수 많은 명령문이 구분 없이 혼재하여 있거나 제어문과 명령문 사이의 영역을 구분하지 않으면 소스 코드 분석이 어려워진다.\n\n=== 함수 선언 후 빈 줄 사용 지양\n함수를 선언한 경우에는 다음에 빈 줄을 삽입하지 않는다. \n[source.js]\n.나쁜 예\n----\nfunction _getXHR(){\n\n\tif(window.XMLHttpRequest){\n\t\treturn new XMLHttpRequest();\n\t}else if (ActiveXObject){\n\t\t...\n\t} \n\n}\n----\n[source.js]\n.좋은 예\n----\nfunction _getXHR(){\n\tif(window.XMLHttpRequest){ /* (빈 줄 위치) 메소드 선언 후 다음 줄에 빈 줄을 삽입하지 않는다. */\n\t\treturn new XMLHttpRequest();\n\t}else if (ActiveXObject){\n\t\t...\n\t} \n}\n----\n\n=== 함수 선언 간 빈 줄 사용 준수\n=== 변수 선언 후 빈 줄 사용 준수\n[source.js]\n.나쁜 예\n----\nvar i, len, dragonball,\n    items = getItems(),\n    goSportsTeam = true;\n\nvar i, items = getItems(),\n    dragonball,\n    goSportsTeam = true,\n    len;\n----\n\n[source.js]\n.좋은 예\n----\nvar items = getItems(),\n    goSportsTeam = true,\n    dragonball,\n    length,\n    i;\n----\n\n=== 명령문, 제어문간 빈 줄 사용 준수 \n\n[source.js]\n.좋은 예\n----\nreq.open(opt.method.toUpperCase(), this._url, true);\nreq.setRequestHeader(\"charset\", \"utf-8\");\n/* (빈 줄 위치) 명령문과 제어문 사이에는 빈 줄을 삽입한다. */\nfor(var x in this._headers){\n\tif(typeof this._headers[x] == \"function\"){\n\t\tcontinue;\n\t}\n\t/* (빈 줄 위치) 명령문과 제어문 사이에는 빈 줄을 삽입한다. */\n\treq.setRequestHeader(x, this._headers[x]);\n}\n/* (빈 줄 위치) 명령문과 제어문 사이에는 빈 줄을 삽입한다. */\nif(typeof req.onload != \"undefined\"){\n\treq.onload = function(rq){\n\t\tclearTimeout(_timer);\n\t\tt._onload(rq)\n\t};\n}else{\n\treq.onreadystatechange = function(rq){\n\t\tclearTimeout(_timer);\n\t\tt._onload(rq)\n\t}; \n}\n----\n\n== 새 줄(New Lines)\n\n=== 오브젝트 리터럴은 키와 값을 한 쌍으로 새 줄을 삽입한다.\n[source.js]\n.나쁜 예\n----\nvar o2 = {\n  a: 0, b: 1,\n  c: 2, 'strange key': 3\n};\n----\n\n[source.js]\n.좋은 예\n----\nvar o2 = {\n  a: 0,\n  b: 1,\n  c: 2,\n  'strange key': 3\n};\n----\n\n=== else if, else 문 새 줄 사용 지양 \n=== catch, finally 문 새 줄 사용 지양 \n=== do 문 새 줄 사용 지양 \n[source.js]\n.나쁜 예\n----\nif(true){\n\treturn;\n}\nelse if(false){\n\treturn;\n}\nelse{\n\treturn;\n} \n----\n\n[source.js]\n.좋은 예\n----\nif(true){\n\treturn;\n}else if(false){\n\treturn;\n}else{\n\treturn;\n} \n----\n\n=== 한 줄 명령문 새 줄 사용 준수 \n=== 함수의 빈 블록, 빈 몸체 새 줄 사용 준수(for, do..)\n[source.js]\n.나쁜 예\n----\nfunction Empty() {}\n----\n\n[source.js]\n.좋은 예\n----\nfunction Empty() {\n}\nfunction Example() {\n\tvar oListener = new Listener({});\n\tfoo = function(){\n\t\tdo{\n\t\t}while(false);\n\t\tfor(;;){\n\t\t}\n\t}\n} \n----\n\n=== 파라미터, 닫는 괄호간 새 줄 사용 지양 \n[source.js]\n.나쁜 예\n----\nvar aNewArray = aArray.filter(function(v, i, o){ return v > 50; }); \n----\n[source.js]\n.좋은 예\n----\nvar aNewArray = aArray.filter(function(v, i, o){\n\treturn v > 50;\n}); \n----\n\n== 공백 (White spaces)\n\n=== 탭에는 공백 2개를 설정하십시오.\n[source.js]\n.나쁜 예\n----\nfunction() {\n∙∙∙∙var name;\n}\n\nfunction() {\n∙var name;\n}\n----\n[source.js]\n.좋은 예\n----\nfunction() {\n∙∙var name;\n}\n----\n\n=== 중괄호({})의 앞에 공백을 하나 넣는다.\n[source.js]\n.나쁜 예\n----\nfunction(){\n\n}\nvar obj ={\n\n};\n----\n[source.js]\n.좋은 예\n----\nfunction() {\n\n}\nvar obj = {\n\n};\n----\n\n=== 단항 연산자(!, ++..)와 피연산자 사이에 공백을 두지 않는다.\n[source.js]\n.나쁜 예\n----\n! isCapital;\n++ windex;\nindex ++;\n----\n[source.js]\n.좋은 예\n----\n!isCapital;\n++windex;\nindex++;\n----\n\n=== 종료 구분자(;) 앞에는 공백 사용 지양.\n[source.js]\n.나쁜 예\n----\nvar obj = []∙;\n----\n[source.js]\n.좋은 예\n----\nvar obj = [];\n----\n\n=== 콤마(,)은 뒤에 공백을 삽입한다. \n=== 콜론(:)을 사용하는 경우에는 반드시 앞과 뒤에 공백을 삽입한다. \n=== 빈 생성자의 경우 공백을 삽입하지 않는다. ({}, [])\n\n== 이름(Names)\n\n=== 공통 규칙\n\n==== 영문 사용\n소스의 변수명, 클래스명 등에는 영문 이외의 언어를 사용하지 않는다.\n\n==== 한글 발음 사용 금지\n한글 발음을 그대로 사용하지 않는다.\n\n''무형자산''이라는 의미의 변수를 예로 들면 아래와 같다.\n\n- 나쁜 예 : `moohyungJasan`\n- 좋은 예 : `intangibleAssets`\n\n==== 특수 문자 사용 금지\n클래스, 메소드 등의 이름에는 특수 문자를 사용하지 않는다. jQuery변수의 경우 $을 사용하는 것은 예외사항으로 한다.\n[source.js]\n.나쁜 예\n----\nfuntion $some() {\n\t\n}\n----\n\n==== 네임스페이스, 오브젝트, 함수, 그리고 인스턴스로는 camelCase를 사용하십시오.\n[source.js]\n.나쁜 예\n----\nvar ajax_history = new AjaxHistory(...);\n----\n\n[source.js]\n.좋은 예\n----\nvar ajaxHistory = new AjaxHistory(...);\n----\n\n\n=== 네임스페이스 명명 규칙 \n==== 소문자 사용 준수 \n[source.js]\n.나쁜 예\n----\nnaver.FOO.bar = function() {\n\t\n}\n----\n\n[source.js]\n.좋은 예\n----\nnaver.foo.bar = function() {\n\t\n}\n----\n\n=== 클래스명\n==== 명사 사용 준수 \n==== Class와 생성자에는 PascalCase를 사용하십시오.\n[source.js]\n.나쁜 예\n----\nvar eventDelegator = eg.Class(...);\n----\n\n[source.js]\n.좋은 예\n----\nvar EventDelegator = eg.Class(...);\n----\n\n=== 메서드명(Methods)\n==== 동사 사용 준수 \n==== 외부에서 접근할 가능성이 있는 private 메서드는 밑줄 _을 사용한다.\n.나쁜 예\n----\neg.Class({\n\t\"privateMethod\" : function() {\n\n\t}\n});\n----\n\n[source.js]\n.좋은 예\n----\neg.Class({\n\t\"_privateMethod\" : function() {\n\n\t}\n});\n----\n==== 외부에서 접근할 수 없는 경우는 일반적인 메서드 명으로 만든다.\n[source.js]\n.나쁜 예\n----\n(function(){\n\tfunction _privateMethod() {\n\n\t}\n\n\tfunction publicMethod()) {\n\t\t_privateMethod();\n\t}\n})();\n----\n\n[source.js]\n.좋은 예\n----\n(function(){\n\tfunction privateMethod() {\n\n\t}\n\n\tfunction publicMethod() {\n\t\tprivateMethod();\n\t}\n})();\n----\n\n\n=== 변수명\n==== 명사 사용 준수 \n==== this의 참조를 저장할 때 self 를 사용하십시오. 깊이가 깊은 경우 적절하게 작명하지만 가능하면 $.proxy, bind을 활용하세요.\n[source.js]\n.나쁜 예\n----\nvar foo = {\n\t\"some\" : function() {\n\t\tvar _this = this;\n\t\tsetTimeout(function() {\n\t\t\t_this.thing();\n\t\t},1000);\n\t},\n\t\"thing\" : function() {\n\t}\n}\n----\n\n[source.js]\n.좋은 예\n----\nvar foo = {\n\t\"some\" : function() {\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tself.thing();\n\t\t},1000);\n\t},\n\t\"thing\" : function() {\n\t}\n}\n----\n==== jQuery레퍼런스의 경우 $을 접미사로 일반적인 변수명에 준하여 작성합니다.\n[source.js]\n.나쁜 예\n----\nvar foo = {\n\t\"some\" : function() {\n\t\tvar base = jQuery(\"#base\");\n\t}\n}\n----\n\n[source.js]\n.좋은 예\n----\nvar foo = {\n\t\"some\" : function() {\n\t\tvar $base = jQuery(\"#base\");\n\t}\n}\n----\n\n\n=== 속성명\n==== 외부에서 접근할 수 있는 속성은 밑줄 _을 사용한다.\n.나쁜 예\n----\neg.Class({\n\t\"privateState\" : true\n});\n----\n\n[source.js]\n.좋은 예\n----\neg.Class({\n\t\"_privateState\" : true\n});\n----\n==== 외부에서 접근할 수 없다면 _을 넣지 않는다.\n[source.js]\n.나쁜 예\n----\n(function(){\n\tvar _privateState = true;\n\n\tfunction publicMethod() {\n\t\t_privateState;\n\t}\n})();\n----\n\n[source.js]\n.좋은 예\n----\n(function(){\n\tvar privateState = true;\n\n\tfunction publicMethod() {\n\t\tprivateState;\n\t}\n})();\n----\n\n=== 상수 이름\n==== 대문자 사용 준수 \n[source.js]\n.나쁜 예\n----\nvar firefox = 1;\nvar is_left = true;\n----\n\n[source.js]\n.좋은 예\n----\nvar FIREFOX = 1;\nvar IS_LEFT = true;\n----\n\n== 변수 선언\n=== 변수 선언은 해당 스코프 상단에 등록한다.\n[source.js]\n.나쁜 예\n----\nfunction foo() {\n\tvar i = 0;\n\tif(i > 0) {\n\t\tvar j = 0;\n\t}\n}\n----\n\n[source.js]\n.좋은 예\n----\nfunction foo() {\n\tvar i = 0;\n\tvar j = 0;\n\tif(i > 0) {\n\t\tj = 0;\n\t}\n}\n----","markerStore":{"version":2,"nextMarkerId":39,"markersById":{"0":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","editorId":447},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}},"history":{"version":2,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/naver/nhn_work/git/Coding-Convention/js/js.adoc","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7b73ca5475097c4d5a9cd278ec4f41827b142922","deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"children":[{"id":3,"items":[{"id":443,"softTabs":true,"displayBuffer":{"id":444,"softWrapped":true,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/naver/nhn_work/git/Coding-Convention/java/src/java.adoc","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":447,"softTabs":true,"displayBuffer":{"id":448,"softWrapped":true,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/naver/nhn_work/git/Coding-Convention/js/js.adoc","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":439,"softTabs":true,"displayBuffer":{"id":440,"softWrapped":true,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/naver/nhn_work/git/Coding-Convention/cpp/src/index.adoc","deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/naver/nhn_work/git/Coding-Convention/java/src/java.adoc","focused":false,"flexScale":1,"deserializer":"Pane"},{"id":438,"items":[{"deserializer":"AsciiDocPreviewView","filePath":"/Users/naver/nhn_work/git/Coding-Convention/markup/markup.adoc","editorId":"430"},{"deserializer":"AsciiDocPreviewView","filePath":"/Users/naver/nhn_work/git/Coding-Convention/java/src/java.adoc","editorId":"443"}],"activeItemURI":"asciidoc-preview://editor/443","focused":false,"flexScale":1,"deserializer":"Pane"}],"orientation":"horizontal","flexScale":1,"deserializer":"PaneAxis"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/naver/nhn_work/git/Coding-Convention/java/src/java.adoc":1433308905687,"/Users/naver/nhn_work/git/Coding-Convention/js/js.adoc":1433308520049,"/Users/naver/nhn_work/git/Coding-Convention/cpp/src/index.adoc":1433308519408},"metrics":{"sessionLength":734921},"tree-view":{"directoryExpansionStates":{"/Users/naver/nhn_work/git/Coding-Convention":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},"cpp":{"isExpanded":true,"entries":{"src":{"isExpanded":true,"entries":{}}}},"gradle":{"isExpanded":false,"entries":{}},"java":{"isExpanded":true,"entries":{"src":{"isExpanded":true,"entries":{}}}},"js":{"isExpanded":true,"entries":{}},"style":{"isExpanded":false,"entries":{}},"markup":{"isExpanded":true,"entries":{}}}},"/Users/naver/nhn_work/git/mail":{"isExpanded":false,"entries":{}}},"selectedPath":"/Users/naver/nhn_work/git/Coding-Convention/java/src/java.adoc","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":0,"width":203},"keybinding-resolver":{},"term2":{"termViews":["",""]},"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false,"wholeWord":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["is_heart","1em","2em","showColorsForImage","view_layer"],"replaceHistory":["$ut","$ut*2"],"pathsHistory":["$ut","$ut*2"]}}}